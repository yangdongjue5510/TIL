# 타임리프 기본 사용법

## 선언

```html
<html xmlns:th="http://www.thymeleaf.org">
```

## Escape

html은 < , >가 기반으로 정의되는데, 이런 문자가 사용될 때 주의해야함.

만약 무지성으로 변수 이름에 <, >를 넣어주면 타임리프가 알아서 escape시켜버린다.

```java
model.setAttribute("data", "<b>hello!!</b>");

th:text="${data}" //태그 속 적용
[[${data}]] //컨텐츠 속 적용
```

이렇게 하면 **hello!!** 로 결과가 나오길 바랬지만, <\b>hello!<\/b> 이렇게 escape되서 나오게 된다..

## Unescape

escape를 해제하려면

```java
th:utext=${data} //태그 속 적용
[($data)] //컨텐츠 속 적용
```

이렇게 해주면 된다!



# 변수

## 변수 표현 ${...}

```html
th:text="${item.price}"
```

## SpringEL 표현식

```html
${객체명.필드명}
${객체명['필드명']}
${객체명.get필드명()}
```

그냥 객체 이름을 통해서도 접근 가능하고,
문자열로 통해서도 접근 가능하고,
프로퍼티 접근을 통해서 접근 가능하다.

## 지역 변수

```html
th:with="변수명=${객체이름}"
```

이렇게 하면 선언한 태그 안에서만 유효한 지역변수를 선언할 수 있다.



# 기본 객체와 편의 객체

타임리프는 많이 사용되는 객체들은 직접 지원하고 있다.
직접 변수로 만들지 않아도 된다.

```html
기본 객체
${#request} 요청객체
${#response} 응답객체
${#session} http세션
${#servletContext} 서블릿 컨텍스트
${#locale} 지역정보

편의 객체
${param.paramData} 
요청파라미터 중 paramData를 직접 가져올 수 있다.

${session.sessionData} 
세션에 담아둔 sessionData를 그냥 가져올 수 있다.

${@helloBean.hello('Spring!')} 
스프링 bean도 이름을 통해 직접 접근가능하다.
```



##  유틸리티 객체와 날짜

유틸리티 객체는 종류가 엄청 많으니까 도큐멘트 참고하자.

https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html#appendix-b-expression-utility-objects

### 자바 8 날짜

타임리프에서 자바8 날짜인 LocalDate, LocalDateTime, Instant를 쓰려면 라이브러리를 추가해야함.

**thymeleaf-extras-java8time** 부트에서는 자동으로 추가되어있다.

타임리프에서는 **#temporals**를 통해 날짜정보를 접근할 수 있다.

```html
<span th:text="${#temporals.format(localDateTime, 'yyyy-MM-dd HH:mm:ss')}"></span>
```



# URL 링크

 타임리프에서 여러 변수를 활용해서 링크를 만들 수 있다.

```html
기본적인 링크 /hello
th:href="@{/hello}"

경로변수 /hello/data1/data2
th:href="@{/hello/{param1}/{param2}(param1=${param1}, param2=${param2})}"

쿼리파라미터 /hello/data1?param2=data2
th:href="@{/hello/{param1}(param1=${param1}, param2=${param2})}"
```

즉 괄호 안에 있는 값들은, 경로 변수에 모두 매핑되고 나면, 모두 쿼리파라미터로 처리된다~!



# 리터럴

리터럴? 소스 코드 상에서 고정된 값을 말하는 용어

타임리프는 문자, 숫자, 불린, null을 리터럴로 인식한다.

특히 문자 리터럴은 항상 작은 따옴표로 감싸야하는데,
공백없이 이어지면 타임리프는 리터럴로 처리해준다.
(하지만 공백이 있으면 안됨.)

```html
<span th:text="'hello'"></span> 굳!
<span th:text="hello"></span> 굳!
<span th:text="'hello world!'"></span> 굳!
<span th:text="hello world!"></span> 안됨!!
```

## 리터럴 대체

리터럴이 너무 신경 쓸 일이 많다...
그래서 통째로 문자열로 해석해주는 리터럴 대체 방법이 있다.

```html
<span th:text="'hello '+${var1}"></span> 리터럴 방식..(번거롭다.)
<span th:text="|hello ${var1}|"></span> 리터럴 대체!
```

## 조건식. Elvis 연산자. No operation

```html
<li> (10 % 2 ==0)? '짝수':'홀수'</li> 일반적인 조건문
<li>${data}?: '데이터가 없네요.'</li> Elvis 연산자(3항연산의 축약버전)
<li>$(nullData)?: _</li><span>데이터가 없습니다.</span> no operation(_) 거짓일 경우 아예 타임리프 무시
```

## 속성

태그 안에 **th:~~="@@"**를 적어주면 태그로 추가한다.(이미 있으면 대체한다.)
th:attrappend="@@=&&" 이건 @@속성 뒤에 &&를 붙이는거
th:attrprepend="@@=&&" 이건 @@속성 뒤에 &&를 붙이는거
**th:classappend="@@"** 이건 클래스 속성 뒤에 @@붙이는거

th:checked="false" 이건 checked를 하지않음.(html에서는 checked가 있으면 값상관없이 체크됨.)

```html
<input type="text" name="mock" th:name="userA" /> 대체
<input type="text" class="text" th:classappend="large" /> text large
<input type="checkbox" name="active" th:checked="false" /> 체크안됨
```

## 반복

```html
  <tr th:each="user : ${users}">
    <td th:text="${user.username}">username</td>
    <td th:text="${user.age}">0</td>
```

두번째 인자를 넣어주면(안넣어주면 첫번째인자 + Stat) 현재 반복상태를 알려주는 변수를 쓸 수 있다.

```html
  <tr th:each="user, userStat : ${users}"> 두번째 인자로 userStat을 줬다.
    <td th:text="${userStat.count}">username</td> 1부터 시작하는 값
    <td th:text="${user.username}">username</td>
    <td th:text="${user.age}">0</td>
    <td>
      index = <span th:text="${userStat.index}"></span>
      count = <span th:text="${userStat.count}"></span>
      size = <span th:text="${userStat.size}"></span>
      even? = <span th:text="${userStat.even}"></span>
      odd? = <span th:text="${userStat.odd}"></span>
      first? = <span th:text="${userStat.first}"></span>
      last? = <span th:text="${userStat.last}"></span>
      current = <span th:text="${userStat.current}"></span>
```

## 조건문

if, unless(if와 반대)는 th:if, th:unless로 표현하는데, 조건식이 거짓이면 그 행 자체를 없는 셈친다.

```html
<tr th:each="user, userStat : ${users}">
 <td th:text="${userStat.count}">1</td>
 <td th:text="${user.username}">username</td>
 <td>
 <span th:text="${user.age}">0</span>
 <span th:text="'미성년자'" th:if="${user.age lt 20}"></span>
 <span th:text="'미성년자'" th:unless="${user.age ge 20}"></span>
 </td>
 </tr>
```

switch문은 다 만족하지 않을 경우 *로 간다.

```html
<td th:switch="${user.age}">
 <span th:case="10">10살</span>
 <span th:case="20">20살</span>
 <span th:case="*">기타</span>
 </td>
```

## 주석

html 주석, 타임리프 파서 주석, 타임리프 프로토타입 주석이 있다.

```html
html 주석
<!--
<span th:text="${data}">html data</span>
-->

타임리프 파서 주석 : 타임리프를 적용시킬 때 사용되는 주석(렌더링 자체가 안됨)
<!--/* [[${data}]] */-->
<!--/*-->
<span th:text="${data}">html data</span>
<!--*/-->

타임리프 프로토타입 주석 : 웹브라우저 파일로 열 때는 안보이지만, 타임리프로 열면 보임
<!--/*/
<span th:text="${data}">html data</span>
/*/-->
```

## 블록

타임리프는 html 태그안에 속성으로 활용되는데, 타임리프 태그가 필요할 때 블록을 사용한다.

```html
<th:block th:each="user : ${users}">
  <div>
    사용자 이름1 <span th:text="${user.username}"></span>
    사용자 나이1 <span th:text="${user.age}"></span>
  </div>
  <div>
    요약 <span th:text="${user.username} + ' / ' + ${user.age}"></span>
  </div>
</th:block>
```

## 자바스크립트 인라인

1. 텍스트는 자연스럽게 " "로 감싼다.
2. 내추럴 템플릿을 사용가능하게 한다. (html로 열어도 되고, )
