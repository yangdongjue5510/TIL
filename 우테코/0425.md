# 데일리

1. 테스트 디비 설정 -> 테스트 패키지의 리소스 폴더에 스키마와 프로퍼티
2. 생상자 주입은 순환참조를 막을 수 있다.
3. json으로 객체 반환시 getter를 제공해줘야 한다. 그리고 직렬화 될 때 `is~` 이런 변수명은 is가 제거된 상태로 직렬화 된다.
4. GET은 캐싱이 된다.
5. 예외 처리는 사용자에게 노출되어야 하는 예외와 개발자가 로깅으로 내부 기록해야하는 경우를 생각하라.

# 그림으로 배우는 HTTP

1. 하이퍼텍스트
   문서간에 상호간에 연결을 짓는 방식.

2. HTTP 하이퍼텍스트 트랜스퍼 프로토콜
   웹에서 클라이언트 - 서버가 통신하기 위한 약속

3. WWW
   하이퍼텍스트를 기반으로 문서들을 참조할 수 있게 하는 것이 웹.
   웹은 = HTML(문서 양식) + HTTP(통신 양식) + URL(문서의 주소를 나타냄)으로 이뤄짐

4. 프로토콜
   서로 다른 하드웨어와 운영체제를 가진 놈들이 소통하려면 규칙이 있어야 한다.

5. TCP/IP
   인터넷과 관련된 프로토콜의 통칭이라는데,,, TCP 프로토콜과 IP 프로토콜 기반의 프로토콜을 의미하는 듯 하다.

6. 계층화
   관심사에 따라 계층화해서 사양이 바뀌는 부분을 간단히 교체하면 변화에 잘 대응할 수 있다.
   또 설계를 편하게 할 수 있다. 어플리케이션 계층은 하위 계층에 대해 관심 두지 않아도 된다.

   1. 애플리케이션 계층 : 유저에게 제공되는 통신의 움직임 결정
   2. 트랜스포트 계층 : 접속한 두 개의 기기 사이의 데이터 흐름을 결정 (TCP, UDP)
   3. 네트워크 계층 : 패킷의 이동 경로나 절차(데이터 최소 단위)
   4. 링크 계층 : 네트워크의 하드웨어

7. 통신의 흐름
   HTTP 요청 -> 클라이언트 애플리케이션 -> 클라이언트 트랜스포트(포트번호 추가) -> 클라이언트 네트워크(맥주소 추가) -> 클라이언트 링크
   서버 측은 요청의 역순.
   요청이 시작되면

   1. 애플리케이션 : http 데이터
   2. 트랜스포트 : http 데이터 + TCP 헤더
   3. 네트워크 : http 데이터 + TCP 헤더 + IP 헤더
   4. 링크 : http 데이터 + TCP 헤더 + IP 헤더 + 이더넷 헤더

   이렇게 하위로 갈 수록 데이터는 다양한 헤더에 의해 캡슐화 된다.
   서버측으로 오면, 헤더를 역순으로 하나씩 제거하여 데이터를 수신한다.

8. Ip? 개개의 패킷을 상대방에게 정확하게 전달!

   1. ip 주소 : 각 노드에 부여된 주소
   2. Mac 주소 : 각 네트워크 카드에 할당된 주소. 변경 불가.

   ip는 mac주소를 통해 정확한 위치로 보낸다.
   이때 arp라는 프로토콜이 활용된다.

   1. Arp는 택배 배송과 같다. 그냥 다음 도착지만 알고 나머지는 그 쪽 사람들한테 맡긴다.

9. TCP? 신뢰성 있는 바이트 스트림 서비스.

   1. 큰 용량의 데이터를 보내기 쉽게 TCP 세그먼트로 나누고 일련번호를 부여.
   2. 그 데이터들이 잘 도착했는지 확인한다.(three way handshaking)

10. DNS? 어플리케이션 계층에서 특정 이름에 해당하는 IP주소를 알려준다.

11. HTTP는 Stateless
    서로 이전에 어떤 데이터를 주고 받았는지 프로토콜 상에는 기억하지 않는다.
    많은 데이터를 빠르고 정확하게 처리하기 위해서 간단하게 설계한 것.
    하지만 상황에 따라 데이터를 저장해야될 때도 있음(쿠키, 세션)

12. HTTP METHOD

    1. GET : 리소스 획득(이 정보를 알고싶어!)
    2. POST: 엔티티 전송(이 정보를 알려줄게!)
    3. PUT: 파일 전송(이 정보를 기억해줘!, 해당 리소스에 해당 파일을 기록해놓길 바람)
       인증 기능이 없어서 REST와 웹끼리 연계할 때 사용됨(웹어플리케이션에서 인증)
    4. DELETE: 파일 삭제(해당 리소스에 파일을 삭제해놓길 바람)
       PUT과 마찬가지로 인증기능이 없음.
    5. HEAD, TRACE, OPTION 등,,,

13. HTTP 연결 지속
    하나 가져올 때마다 TCP를 열고 닫으면 오버헤드가 엄청 큼.
    TCP를 열어놓고 모든걸 다 보내고 종료하는 방식으로 하면 웹페이지가 더 빠르게 될 것.

    - 파이프라인화
      지속 연결을 해놓고 하나의 요청을 보내고 응답이 올때까지 기다리는게 아니라, 내가  원하는 리소스의 요청을 기다리지않고 다보내놓는게 더 빠르다.

14. HTTP 메시지
    HTTP 통신의 기본단위. 메시지 헤더 + 개행문자 + 메시지 바디로 구성.

15. 메시지 VS 엔티티?????

16. 인코딩
    인코딩을 하면 데이터를 압축할 수 있다. 다만 압축하는 과정이 추가되므로 CPU에 더 부담이 될 수는 있다.

17. MIME

