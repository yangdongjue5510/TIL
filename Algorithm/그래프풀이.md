## 그래프

자료구조로써 그래프 = 정점(vertex) + 간선(edge)

간선 = (무방향 / 방향) + 가중치

Deg(x) = 정점 x에 연결된 간선 갯수(정점의 차수). 모든 차수를 더하면 그래프의 간선 갯수 두배.

**그래프를 저장하는 두가지 방법**

1. 인접 행렬 : 이차원 배열을 만들어서 연결 여부를 표시
   v개의 정점이 있을 경우 V^2의 공간 사용
   두 정점 간 이동 가능을 검사할 때 상수시간 걸림.
   한 점점에서 갈 수 있는 다른 정점 찾기는 정점 갯수 만큼 걸림
2. 인접 리스트 : 2차원 arrayList로 연결된 것만 기록 ArrayList<ArrayList\<Integer>>
   e개의 간선이 있을 때 e만큼 공간 사용
   두 정점간 이동 가능 검사할 때 두 점의 차수 중 낮은 것 만큼 걸림
   한 점점에서 갈 수 있는 다른 정점 찾기는 그 차수 만큼 걸림



**즉 두 정점을 연결 여부를 빨리 확인하고 싶으면 인접 행렬을 사용!**
**한 정점과 연결된 모든 정점을 확인하고 싶고, 공간 복잡도를 고려하면 인접리스트를 사용!**



문제 풀이 핵심

**문제 속 정점과 간선에 대한 정확한 정의**

**간선 저장 방식 확인!**



## 탐색

시작점에서 간선을 0개 이상 사용해서 갈 수 잇는 정점들은 무엇인가?

1. 깊이 우선(DFS)

   ```java
   static void dfs(int x){
     
     visit[x] = true;
     
     for (int y : x에서 갈 수 있는 모든 점들){
       if(visit[y]) //y를 이미 가본 적 있음.
         continue;
       //y에서 갈 수 있는 곳을 확인
       dfs(y);
     }
   }
   
   main(){
     dfs(5);
   }
   ```

   - 모든 정점이 x로 한번씩 등장한다.
   - for문은 인접 행렬 일 경우 정점만큼, 인접 리스트인 경우 x의 차수 만큼 수행
   - 결국 인접행렬은 정점갯수(V)^2, 인접 리스트는 간선 갯수(E)만큼 수행
   - 인접 리스트로 구현하는게 어지간하면 빠르다.

2. 너비 우선(BFS)

   ```java
   static void bfs(int start){
     Queue<Integer> que = new LinkedList<>();
     
     //start는 방문 가능한 점이니 que에 넣는다.
     que.add(start);
     visit[start] = true; //시작점을 가봤다는게 중요!
     
     while(!que.isEmpty()) {
       int x = que.poll();
       
       for(int y : x 에 갈 수 잇는 점들){
         if (visit[y]) continue; //이미 가본 곳이면 무시
         
         //y에 갈 수 있으면 que에 넣고 visit처리
         que.add(y);
         visit[y] = true;
       }
     }
   }
   ```

   > Queue가 들고 있는 자료의 의미

   큐에는 방문 가능한 정점을 담아두는 곳이다.
   만약 큐가 비었다면, 시작점에서 갈 수 있는 모든 점을 찾아냈다는 걸 의미한다.

   - 방문처리를 할 때, 큐에서 넣을 때 해야한다!!!!(뽑을 때 하면 안된다.)

